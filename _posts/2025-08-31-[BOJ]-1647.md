---
title: "[BOJ] 1647: 도시 분할 계획 (C/C++)"
date: 2025-08-31 01:00:48 +0900
categories: [Algorithm, problems]
tags: [minimum spanning tree, union find, c/c++]     # TAG names should always be lowercase
description: ""
math: true
---
## 문제 [1647번: 도시 분할 계획](https://www.acmicpc.net/problem/1647)
동물원에서 막 탈출한 원숭이 한 마리가 세상구경을 하고 있다. 그러다가 평화로운 마을에 가게 되었는데, 그곳에서는 알 수 없는 일이 벌어지고 있었다.

마을은 N개의 집과 그 집들을 연결하는 M개의 길로 이루어져 있다. 길은 어느 방향으로든지 다닐 수 있는 편리한 길이다. 그리고 각 길마다 길을 유지하는데 드는 유지비가 있다. 임의의 두 집 사이에 경로가 항상 존재한다.

마을의 이장은 마을을 두 개의 분리된 마을로 분할할 계획을 가지고 있다. 마을이 너무 커서 혼자서는 관리할 수 없기 때문이다. 마을을 분할할 때는 각 분리된 마을 안에 집들이 서로 연결되도록 분할해야 한다. 각 분리된 마을 안에 있는 임의의 두 집 사이에 경로가 항상 존재해야 한다는 뜻이다. 마을에는 집이 하나 이상 있어야 한다.

그렇게 마을의 이장은 계획을 세우다가 마을 안에 길이 너무 많다는 생각을 하게 되었다. 일단 분리된 두 마을 사이에 있는 길들은 필요가 없으므로 없앨 수 있다. 그리고 각 분리된 마을 안에서도 임의의 두 집 사이에 경로가 항상 존재하게 하면서 길을 더 없앨 수 있다. 마을의 이장은 위 조건을 만족하도록 길들을 모두 없애고 나머지 길의 유지비의 합을 최소로 하고 싶다. 이것을 구하는 프로그램을 작성하시오.

## 입력
첫째 줄에 집의 개수 N, 길의 개수 M이 주어진다. N은 2이상 100,000이하인 정수이고, M은 1이상 1,000,000이하인 정수이다. 그 다음 줄부터 M줄에 걸쳐 길의 정보가 A B C 세 개의 정수로 주어지는데 A번 집과 B번 집을 연결하는 길의 유지비가 C (1 ≤ C ≤ 1,000)라는 뜻이다.

임의의 두 집 사이에 경로가 항상 존재하는 입력만 주어진다.

## 출력
첫째 줄에 없애고 남은 길 유지비의 합의 최솟값을 출력한다.

## 문제분석
### 문제 요구사항
- 길은 어느 방향으로든지 다닐 수 있음으로, **마을을 undirected graph로 해석** 할 수 있음
- **서로 길이 이어진 집들을 하나의 set**으로 해석 가능
- **길의 유지비의 합을 최소로 구해야 함**

undirected graph의 minimum spanning tree를 구하기 위하여 Kruskal 알고리즘 사용<br>
집이 연결될 때마다 set들을 합쳐야 하기 때문에 union find 알고리즘 사용

### 구현
Kruskal 알고리즘 활용을 위하여 모든 길을 비용을 기준으로 오름차순으로 정렬<br>
Union find 알고리즘 활용을 위하여 각 집이 어느 set에 있는지 확인을 위한 GetSet과 MergeSets 구현

### 증명
**Kruskal 알고리즘을 활용**하여 minimum cost route를 찾은 후, 해당 ****route에 해당하는 집들이 다른 set에 속해 있다면 union set을 진행**,
이때 $\boldsymbol{number\; of\; sets = 2}$ 가 될 때, cost의 합을 출력함으로써, **Kruskal 알고리즘 특성에 의하여 문제의 요구사항이 충족**됨,
## 코드
```cpp
#include <algorithm>
#include <iostream>
#include <tuple>
#include <vector>

std::vector<int> sets;

struct Compare {
  const bool operator()(const std::tuple<int, int, int>& lt,
                        const std::tuple<int, int, int>& rt) {
    return std::get<2>(lt) < std::get<2>(rt);
  }
};

std::istream& operator>>(std::istream& is, std::tuple<int, int, int>& t) {
  is >> std::get<0>(t) >> std::get<1>(t) >> std::get<2>(t);
  return is;
}

const int GetSet(const int set) {
  if (sets[set] == set) {
    return set;
  }
  return sets[set] = GetSet(sets[set]);
}

void MergeSets(int lset, int rset) {
  lset = GetSet(lset);
  rset = GetSet(rset);

  if (lset <= rset) {
    sets[rset] = lset;
  } else {
    sets[lset] = rset;
  }
  return;
}

int main() {
  std::ios::sync_with_stdio(false);
  std::cin.tie(nullptr), std::cout.tie(nullptr);

  int N, M;
  std::cin >> N >> M;

  int number_of_sets = N;
  sets.resize(N + 1);
  for (int i = 1; i < sets.size(); ++i) {
    sets[i] = i;
  }

  std::vector<std::tuple<int, int, int>> routes(M);
  for (auto& route : routes) {
    std::cin >> route;
  }
  std::sort(routes.begin(), routes.end(), Compare());

  int ans = 0;
  auto iter = routes.begin();
  for (auto iter = routes.begin(); iter != routes.end() && number_of_sets > 2;
       ++iter) {
    const int set_a = GetSet(std::get<0>(*iter));
    const int set_b = GetSet(std::get<1>(*iter));
    if (set_a == set_b) {
      continue;
    }
    MergeSets(set_a, set_b);
    ans += std::get<2>(*iter);
    --number_of_sets;
  }

  std::cout << ans;

  return 0;
}
```